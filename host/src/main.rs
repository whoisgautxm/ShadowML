// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{ZK_DTP_ELF, ZK_DTP_ID};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use std::io;
use std::fs;

fn main() {
    // Make the prover.
    // TODO: Implement communication with the guest here
    println!("Please input the sepal length, sepal width, petal length, petal width.");

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    let mut s = input.split_whitespace();

    let sepal_length: u32 = s.next().unwrap().parse().unwrap();
    let sepal_width: u32 = s.next().unwrap().parse().unwrap();
    let petal_length: u32 = s.next().unwrap().parse().unwrap();
    let petal_width: u32 = s.next().unwrap().parse().unwrap();

    let data: (u32, u32, u32, u32) = (sepal_length, sepal_width, petal_length, petal_width);

    println!("Data is: {:?}", data);

    let env = ExecutorEnv::builder()
        .write(&data)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();

    // Run prover & generate receipt
    let receipt: Receipt = prover.prove(env, &ZK_DTP_ELF).unwrap().receipt;

    let receipt_bin = bincode::serialize(&receipt).unwrap();

    fs::write("receipt.bin", receipt_bin).unwrap();

    let receipt_inner_bytes_array = bincode::serialize(&receipt.inner).unwrap();
    // println!( "Serialized bytes array (hex) INNER: {:?}\n", hex::encode(&receipt_inner_bytes_array));

    fs::write("inner.bin", receipt_inner_bytes_array).unwrap();
    
    let receipt_journal_bytes_array = bincode::serialize(&receipt.journal).unwrap();
    // println!( "Serialized bytes array (hex) JOURNAL: {:?}\n", hex::encode(&receipt_journal_bytes_array));
    fs::write("journal.bin", receipt_journal_bytes_array).unwrap();

    let mut image_id_hex = String::new();
    for &value in &ZK_DTP_ID {
    image_id_hex.push_str(&format!("{:08x}", value.to_be()));}
    println!("Serialized bytes array (hex) IMAGE_ID: {:?}\n", image_id_hex);
    fs::write("image_id.bin", image_id_hex).unwrap();


    // TODO: Implement code for transmitting or serializing the receipt for
    // other parties to verify here

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(ZK_DTP_ID);

    let output: u32 = receipt.journal.decode().unwrap();
    println!("Output is: {}", output);

    println!("Proven with guest ID: {}", guest_id());


    // println!("Proof generated successfully!");

    // // // Extract journal of receipt
    // let c: u32 = from_slice(&receipt.journal).unwrap();

    // let dic = ["setosa", "versicolor", "virginica"];

    // // Print an assertion
    // println!("This is the {} flower, and I can prove it!", dic[c as usize]);
}

fn guest_id() -> String {
    hex::encode(vec_u8_from_u32_slice_little_endian(&ZK_DTP_ID))
}

fn vec_u8_from_u32_slice_little_endian(v: &[u32]) -> Vec<u8> {
    v.iter().flat_map(|&x| x.to_le_bytes().to_vec()).collect()
}